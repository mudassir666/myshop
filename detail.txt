1) Branch master :

video 3 : defining a data model 
1) created a models -> product.dart : blueprint
2) created a screens -> product_overview_screen
3) created a widgets folder

2) Branch video 4 to 10 :

video 4 : 
1) product_overview_screen : 
= gridview.builder
= gridDelegate: SliverGridDelegateWithFixedCrossAxisCount
2) create a widget Product_item : 
= gridtile
= gridtilebar 

video 5:
1) main -> fonts from assets\fonts store in pubspec.yaml
2) product_item : 
= ClipRRect -> to give rounded border , its child is gridtile 
= color icons

video 6:   
                              key                                 value
1) main -> routes { ProductDetailScreen.routeName : (ctx) => ProductDetailScreen() }
2) product_item :
= GestureDetector
= Navigator.of(context).pushNamed ( routename and arrgument )
3) created a screen -> product_detail_screen :
= ModalRoute.of(context)!.settings.arguments  -> to fetch arrguments  

video 9 : working with providers and listeners
1) create providers folder -> products_provider file -> Products class :
= Product class is combine with changeNotifier through mixin
= list of _items which are private 
= to access private list we created getter
= to add product we created function with notifylistener so it could tell all the listers to rebuild widget
2) main -> Wrape Materialapp with ChangeNotifierProvider 
= to listen we need to wrape the child with ChangeNotifierProvider , so it could listen and change the listing widgets
= which class we are listenig ->   create: (ctx) => Products()
3) ProductsOverviewScreen -> we created a ProductsGrid class because we dont need to rebuild the widget tree , we will just rebuild the productGrid whenever it will listen 
= created ProductsGrid -> with a listner -> Provider.of<Products>(context) -> which could access the Products class items and functions

video 11: Listrning in Different places and ways   
                           
1) Product_detail_screen -> use Provider.of<Products>(context) to access product_provider class
= To access the specific product from the item list :

////////////////////////////////logic by me////////////////////////////////////

    final product_provider = Provider.of<Products>(context);
    final product = product_provider.items.firstWhere((product) => product.id == productId);

    //////////////////////////////////his first logic/////////////////////////

      final loadedProduct = Provider.of<Products>(context).items.firstWhere((prod) => prod.id == productId);

    ///////////////////////////////////his second logic/////////////////////// from products_provider

    final loadedProduct = Provider.of<Products>(context,listen: false).findById(productId);

= listen: false = to aviod rebuild because we just need data one time

2) products_provider -> function to find the product from item by matching ids :

=  Product findById(String id) {
    return _items.firstWhere((prod) => prod.id == id);
  }
 
video 12 : Using Nested Models and Providers  
   
1) Shift products_provider.dart into models

2) Product.dart -> add a ChangeNotifier with Product class :
= create a function :  
void toggleFavoriteStatus() {
    // if it is true it will return false and if it is false it will return true
    isFavorite = !isFavorite;
    notifyListeners();
  }

3) Products_grid -> add a ChangeNotifierProvider on ProductItem because we want to listen single product
= create: (c) => products[index]   : which means we are accessing single Product of Product class

4) Product_item -> delete the constructor because we are accessing the product items from provider
= change an icons of favorite and add a function.

video 13 : Exploring alternative provider syntaxes   
   
1) ChangeNotifierProvider.value : to use provider on grid or list use .value , by this provider works well when the data changes for a widget

= to reuse existing object use ChangeNotifierProvider.value

2) ChangeNotifierProvider : whenever to create a new object/instant based on a class use ChangeNotifierProvider . it is used for parent and not to reuse existing object

3) ChangeNotifierProvider automatically dispose the data which has been storing

4) products_grid.dart : 
ChangeNotifierProvider.value(
        // here we just wants to listen single product
        value: products[index],
        child: ProductItem(),
      )

video 14 : user consumer instead of provider.of   
   
1) product_item -> Consumer : To run a sub part of a widget tree and make the Provider.of<Product>(context, listen: false)

= Consumer<Product>(
            builder: (ctx, product/instent, child/_ ) => widget(
//could use child to be static or dont rebuild  
//child : widget()
            )
)


2) Consumer : it is used to shrink the area to rebuild , bs ussi part ko rebuild karta hai jo change hoga 

video 15 : Local state vs App wide state  ( part 1 favorite filltering logic for whole app globally )
   
1) Always use statefull widget for a state that affect a single widget so dont use provider or provider class if you only want to change how something is displaced inside a widget. 
2)  So in product_item :
Consumer<Product>(
            builder: (ctx, product, child) => IconButton(
              onPressed: () {
                product.toggleFavoriteStatus();
              },
              icon: Icon(
                product.isFavorite ? Icons.favorite : Icons.favorite_border,
              ),
              color: Theme.of(context).accentColor,
            ),
          )
here we could use statefull widget by using set state but favirote bs isse page par show nhi hoga iski funcatinally dosaray pages ky leay bhi hai thats why we use provider , ky filtering mai asani ho

3) products_Provider.dart : create a var _showFavoritesOnly = false;
= in item getter use if else ,so if the _showFavoirte is true show all the favorites items and else shoe all the items
= create a 2 functions to make _showfavoritesonly true or false
= call the functions in products_overview_screen

4) Product_overview_screen : new widget PopupMenubutton and popupmenuItem
= make a enum for filterOptions which will be used in popupmenubutton
= create a filtering logic in popupmenubutton and acess those function from procuct_provider through Provider and make it listen : false


video 15 : Local state vs App wide state  ( part 2 favorite fillter only apply for a single screen locally not for whole app )
   
In this video we will use a filtering logic so when we chose favorite it will show favorite items and when we chose all items it will show all the items ,
1) so for this we create a favorite items list in
= Products_ provider.dart -> with a filtering logic 

  List<Product> get favoriteItems {
     // it will return the list which product item isFavorite is true
     return _items.where((prodItem) => prodItem.isFavorite).toList();
  }

2) product_overview_screen -> statefull class 
= new widgets
1) popupmenubutton
2) popupmenuitem
3) filteroption enum
4) so here we create a variable showonlyfavorite which will be pass into Productgrid class 
5) popupmenubutton can make showonlyfavorite true and false

3) products_grid -> it will recive a showonlyfavorite varible 
= if the varibale is true it will pass favoriteItems getter from products_provider class into ProductItems class to show favorite items list otherwise it will pass items getter  


video 16 : Adding shopping cart data 

1) models -> cart.dart :
= create cart items blueprint
= cart has a changenotifier maxin
= use cart items blue print in cart class as a value in Map and key will be product id 
= create a map private _items : Map<String, CartItem> _items;
= create getter items :
  Map<String, CartItem> get items {
    return {..._items};
  }
= create a addItem function where it checks if the item is already exits so it will increase its quantity else add that new item in cart
= Map : .containsKey , .update , .putIfAbsent

video 17 : working with multiple providers

1) As we are going to use cart provider into many screen , so we need to add the cart provider into root -> main.dart
= main.dart -> new widget -> MultiProvider ( providers[] ) = to have many providers for a child
MultiProvider(
      providers: [
        ChangeNotifierProvider(
          create: (ctx) => Products(),
        ),
        ChangeNotifierProvider(
          create: (ctx) => Cart(),
        ),
      ],
      child: MaterialApp()
)

video 18 : connecting the cart provider

1) product_item -> into cart icon add a function called cart.additems by providing cart provider
2) cart.dart -> create a itemcount getter which will tell the items length in cart
3) create a widget class -> badge 
= its contructor need a color , value = itemcount , widget = icon button
4) product_overview_screen -> consumer which has a badge 
= we only need a rebuild a cart value 
= badge icon button should be static

video 19 : Working on the shopping cart & displaying a total 

1) Cart -> create a total amount getter
2) screens -> cart_screen.dart -> new widgets
= spacer() -> takes the all avaliable space like flexiable space
= chip ( lable : child ) -> it draw a chip shape
= called the totalamount getter from Cart class
3) products_overview_screen -> create a navigator for cart_screen in cart button
4) main -> set a router for cart_screen

video 20 : Displaying a list of cart items

1) widgets -> create a class : cart_items.dart
= it show a Card which will be shown into cart_screen -> listview.builder
= it has a contructor
= circular avator , fitted box
2) cart_screen -> Listview into expended to take avaliable space 
= call cart_item contructor to pass parameter to show a card
=  items are in map so all the map values will be converted into list then we will acess it by index one by one 
 itemBuilder: (ctx, i) => CartItem(
                id: cart.items.values.toList()[i].id,
)

video 21 : Making cart  items dismissible

1) models -> cart.dart -> create a remove item function.
2) widgets -> cart_items -> add a new widget on card
= Dismissible -> which will delete the item form cart 
= it has some cool background color item and a remove function
: onDismissed: (direction) {
        // here we just need a data thats why the listen is false
        Provider.of<Cart>(context,listen: false).removeItem(productId);
}
3) cart_screen -> pass a product Id which is a key throug constructor 
= // product id is the key which will be passed
       productId: cart.items.keys.toList()[i]


video 22 : adding product detail data

1) product_detail_screem -> decorate the detail page
= softWrap : if the text is huge so it will be break

video 23 : Providing an Orders Object

1) models -> create a new class -> orders.dart
= it has its own id
= it will need total amount of the cart
= it consist the list of items present in cart
= need a datetime when the order is placed

2) cart -> create a new clear function
= it will clear the cart items and move the items into order list
=  void clear() {
    _items = {};
    notifyListeners();
  }

3) main.dart -> add a order provider into the root 

video 24 : Adding Orders

1) cart_screen -> add addOrder function
= in order now button :  
 onPressed: () {
                      //converting cart items.object into a list of cart items.object instead of passing whole map
                      Provider.of<Orders>(context, listen: false).addOrder(
                        cart.items.values.toList(),
                        cart.totalAmount,
                      );
                      // after passing items to order we want to clear the cart
                      cart.clear();
                    }

= here we are pass item values as a list and total amount and clearing the cart


video 25 :Adding an order screen

1) screen -> create a class -> orders_screen
= call a order provider
= pass the order provider through constructor

2) widgets -> create a widget class -> order_item
= add a intl package
= create a card which will be shown into orders_screen

video 26 : Using a side Drawer

1) widgets -> create a widget -> app_drawer
= it has two routes
= shop -> product_overview_screen
= order -> order_screen

2) add drawer into
= product_overview_screen
= order_screen

3) set Order_Screem route into main


video 27 : Making orders Expandable & statefull widget vs provider

1) Order_Item -> To make changes in a card like expending it or not so for that make it stateful class
= stateful is used for local widget changes
= show a container detail if we click button
= if (_expanded) is true show else dont show


////////////////////////////////////////////////////////////////////////////////////////////////
                                              user input and form

video 2 :  Snackbars & Undoing add to cart

1) product_item -> ScaffoldMessenger.of(context) -> it will access the nearest scaffold widget
= it is use to hide the pervious snackbar
ScaffoldMessenger.of(context).hideCurrentSnackBar();
= it is use to show the snackbar with some funcunallty
ScaffoldMessenger.of(context).showSnackBar( SnackBar() );

2) model -> cart.dart :
= create a new removeSingleItem function which will be added into snackbar
:1 first it will check if the productId exist or not
:2 second it will cheek if it has more than 1 quantity
:3 third it will delete the item if quantity is 0

3) new 
= ScaffoldMessenger.of(context).hideCurrentSnackBar();
= ScaffoldMessenger.of(context).showSnackBar();
= SnackBar()
= SnackBarAction()

video 3 : Showing alert dialogs

1) Cart_item.dart -> confirm dismiss () {} -> it is a conformation msg are you sure to delete it or not
= confirm dismiss function return future
= showDialog -> display a msg , it can have altert dialog , about dialog and more
= Alert dialog -> has many feature like action in which you can return false and true through pop
: Navigator.of(ctx).pop(true);

2) new
= confirmDismiss(){ return Future }
= showDialog()
= AlertDialog()

video 4 : Adding a manage product page


1) Screen -> create a screen -> user_products_screen
= products provider to access items -> title and image
= has appDrawer
= constoctor of user_product_item
= listview.builder -> column (
children: [
              UserProductItem(
                title: productData.items[i].title,
                imgUrl: productData.items[i].imageUrl,
              ),
              Divider(),
            ],
)
= action button in appbar to add product

2) widgets -> create a widgets -> user_product_item
= list tile ->
:1 circular avator having backgoundImage : networkImage
:2 trailing with row having two icon buttons to delete and edit 

3) main -> add user_products_screen route

4) app_drawer -> add user_products_screen navigator

video 5, 6 & 7 : Edit product screen & a problem / using form & working with form inputs / managing form input focus

1) screem -> create new screen -> edit_product_screen
= it will be a statefull because we want to store data tempalally and use  user/Form input
= Form will be used as a body which contain text form field
= listview to show limited text form field , if we need more form so replace listview with singlechildscroll -> column
= textInputAction: TextInputAction.next,  -> this will show a button which will move towards next input
= create a focusnode variable -> which focus on a single input form
: final _priceFocusNode = FocusNode();
= to the form will has to be focused 
: add this -> focusNode: _priceFocusNode,
= from the form which focus other form after submittion 
:  onFieldSubmitted: (_) {
 FocusScope.of(context).requestFocus(_priceFocusNode); }

2) main -> add edit_product_screen navigator

3) user_products_screen -> add the edit_product_screen navigator into the button

4) new
:1 form()
:2 textformfield()
:3 FocusNode()
:4 FocusScope()


