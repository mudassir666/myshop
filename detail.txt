1) Branch master :

video 3 : defining a data model 
1) created a models -> product.dart : blueprint
2) created a screens -> product_overview_screen
3) created a widgets folder

2) Branch video 4 to 10 :

video 4 : 
1) product_overview_screen : 
= gridview.builder
= gridDelegate: SliverGridDelegateWithFixedCrossAxisCount
2) create a widget Product_item : 
= gridtile
= gridtilebar 

video 5:
1) main -> fonts from assets\fonts store in pubspec.yaml
2) product_item : 
= ClipRRect -> to give rounded border , its child is gridtile 
= color icons

video 6:   
                              key                                 value
1) main -> routes { ProductDetailScreen.routeName : (ctx) => ProductDetailScreen() }
2) product_item :
= GestureDetector
= Navigator.of(context).pushNamed ( routename and arrgument )
3) created a screen -> product_detail_screen :
= ModalRoute.of(context)!.settings.arguments  -> to fetch arrguments  

video 9 : working with providers and listeners
1) create providers folder -> products_provider file -> Products class :
= Product class is combine with changeNotifier through mixin
= list of _items which are private 
= to access private list we created getter
= to add product we created function with notifylistener so it could tell all the listers to rebuild widget
2) main -> Wrape Materialapp with ChangeNotifierProvider 
= to listen we need to wrape the child with ChangeNotifierProvider , so it could listen and change the listing widgets
= which class we are listenig ->   create: (ctx) => Products()
3) ProductsOverviewScreen -> we created a ProductsGrid class because we dont need to rebuild the widget tree , we will just rebuild the productGrid whenever it will listen 
= created ProductsGrid -> with a listner -> Provider.of<Products>(context) -> which could access the Products class items and functions

video 11: Listrning in Different places and ways   
                           
1) Product_detail_screen -> use Provider.of<Products>(context) to access product_provider class
= To access the specific product from the item list :

////////////////////////////////logic by me////////////////////////////////////

    final product_provider = Provider.of<Products>(context);
    final product = product_provider.items.firstWhere((product) => product.id == productId);

    //////////////////////////////////his first logic/////////////////////////

      final loadedProduct = Provider.of<Products>(context).items.firstWhere((prod) => prod.id == productId);

    ///////////////////////////////////his second logic/////////////////////// from products_provider

    final loadedProduct = Provider.of<Products>(context,listen: false).findById(productId);

= listen: false = to aviod rebuild because we just need data one time

2) products_provider -> function to find the product from item by matching ids :

=  Product findById(String id) {
    return _items.firstWhere((prod) => prod.id == id);
  }
 
video 12 : Using Nested Models and Providers  
   
1) Shift products_provider.dart into models

2) Product.dart -> add a ChangeNotifier with Product class :
= create a function :  
void toggleFavoriteStatus() {
    // if it is true it will return false and if it is false it will return true
    isFavorite = !isFavorite;
    notifyListeners();
  }

3) Products_grid -> add a ChangeNotifierProvider on ProductItem because we want to listen single product
= create: (c) => products[index]   : which means we are accessing single Product of Product class

4) Product_item -> delete the constructor because we are accessing the product items from provider
= change an icons of favorite and add a function.

video 13 : Exploring alternative provider syntaxes   
   
1) ChangeNotifierProvider.value : to use provider on grid or list use .value , by this provider works well when the data changes for a widget

= to reuse existing object use ChangeNotifierProvider.value

2) ChangeNotifierProvider : whenever to create a new object/instant based on a class use ChangeNotifierProvider . it is used for parent and not to reuse existing object

3) ChangeNotifierProvider automatically dispose the data which has been storing

4) products_grid.dart : 
ChangeNotifierProvider.value(
        // here we just wants to listen single product
        value: products[index],
        child: ProductItem(),
      )

video 14 : user consumer instead of provider.of   
   
1) product_item -> Consumer : To run a sub part of a widget tree and make the Provider.of<Product>(context, listen: false)

= Consumer<Product>(
            builder: (ctx, product/instent, child/_ ) => widget(
//could use child to be static or dont rebuild  
//child : widget()
            )
)


2) Consumer : it is used to shrink the area to rebuild , bs ussi part ko rebuild karta hai jo change hoga 

video 15 : Local state vs App wide state  ( part 1 favorite filltering logic for whole app globally )
   
1) Always use statefull widget for a state that affect a single widget so dont use provider or provider class if you only want to change how something is displaced inside a widget. 
2)  So in product_item :
Consumer<Product>(
            builder: (ctx, product, child) => IconButton(
              onPressed: () {
                product.toggleFavoriteStatus();
              },
              icon: Icon(
                product.isFavorite ? Icons.favorite : Icons.favorite_border,
              ),
              color: Theme.of(context).accentColor,
            ),
          )
here we could use statefull widget by using set state but favirote bs isse page par show nhi hoga iski funcatinally dosaray pages ky leay bhi hai thats why we use provider , ky filtering mai asani ho

3) products_Provider.dart : create a var _showFavoritesOnly = false;
= in item getter use if else ,so if the _showFavoirte is true show all the favorites items and else shoe all the items
= create a 2 functions to make _showfavoritesonly true or false
= call the functions in products_overview_screen

4) Product_overview_screen : new widget PopupMenubutton and popupmenuItem
= make a enum for filterOptions which will be used in popupmenubutton
= create a filtering logic in popupmenubutton and acess those function from procuct_provider through Provider and make it listen : false


video 15 : Local state vs App wide state  ( part 2 favorite fillter only apply for a single screen locally not for whole app )
   
In this video we will use a filtering logic so when we chose favorite it will show favorite items and when we chose all items it will show all the items ,
1) so for this we create a favorite items list in
= Products_ provider.dart -> with a filtering logic 

  List<Product> get favoriteItems {
     // it will return the list which product item isFavorite is true
     return _items.where((prodItem) => prodItem.isFavorite).toList();
  }

2) product_overview_screen -> statefull class 
= new widgets
1) popupmenubutton
2) popupmenuitem
3) filteroption enum
4) so here we create a variable showonlyfavorite which will be pass into Productgrid class 
5) popupmenubutton can make showonlyfavorite true and false

3) products_grid -> it will recive a showonlyfavorite varible 
= if the varibale is true it will pass favoriteItems getter from products_provider class into ProductItems class to show favorite items list otherwise it will pass items getter  


video 16 : Adding shopping cart data 

1) models -> cart.dart :
= create cart items blueprint
= cart has a changenotifier maxin
= use cart items blue print in cart class as a value in Map and key will be product id 
= create a map private _items : Map<String, CartItem> _items;
= create getter items :
  Map<String, CartItem> get items {
    return {..._items};
  }
= create a addItem function where it checks if the item is already exits so it will increase its quantity else add that new item in cart
= Map : .containsKey , .update , .putIfAbsent

video 17 : working with multiple providers

1) As we are going to use cart provider into many screen , so we need to add the cart provider into root -> main.dart
= main.dart -> new widget -> MultiProvider ( providers[] ) = to have many providers for a child
MultiProvider(
      providers: [
        ChangeNotifierProvider(
          create: (ctx) => Products(),
        ),
        ChangeNotifierProvider(
          create: (ctx) => Cart(),
        ),
      ],
      child: MaterialApp()
)

video 18 : connecting the cart provider

1) product_item -> into cart icon add a function called cart.additems by providing cart provider
2) cart.dart -> create a itemcount getter which will tell the items length in cart
3) create a widget class -> badge 
= its contructor need a color , value = itemcount , widget = icon button
4) product_overview_screen -> consumer which has a badge 
= we only need a rebuild a cart value 
= badge icon button should be static

video 19 : Working on the shopping cart & displaying a total 

1) Cart -> create a total amount getter
2) screens -> cart_screen.dart -> new widgets
= spacer() -> takes the all avaliable space like flexiable space
= chip ( lable : child ) -> it draw a chip shape
= called the totalamount getter from Cart class
3) products_overview_screen -> create a navigator for cart_screen in cart button
4) main -> set a router for cart_screen

video 20 : Displaying a list of cart items

1) widgets -> create a class : cart_items.dart
= it show a Card which will be shown into cart_screen -> listview.builder
= it has a contructor
= circular avator , fitted box
2) cart_screen -> Listview into expended to take avaliable space 
= call cart_item contructor to pass parameter to show a card
=  items are in map so all the map values will be converted into list then we will acess it by index one by one 
 itemBuilder: (ctx, i) => CartItem(
                id: cart.items.values.toList()[i].id,
)

video 21 : Making cart  items dismissible

1) models -> cart.dart -> create a remove item function.
2) widgets -> cart_items -> add a new widget on card
= Dismissible -> which will delete the item form cart 
= it has some cool background color item and a remove function
: onDismissed: (direction) {
        // here we just need a data thats why the listen is false
        Provider.of<Cart>(context,listen: false).removeItem(productId);
}
3) cart_screen -> pass a product Id which is a key throug constructor 
= // product id is the key which will be passed
       productId: cart.items.keys.toList()[i]


video 22 : adding product detail data

1) product_detail_screem -> decorate the detail page
= softWrap : if the text is huge so it will be break
